"""change children to descendants counter cache

Revision ID: a77cefd5372a
Revises: 15f76627bb42
Create Date: 2025-08-02 23:00:29.356630

"""
from typing import Sequence, Union

import sqlalchemy as sa

from pgvector.sqlalchemy import Vector

from alembic import op


# revision identifiers, used by Alembic.
revision: str = 'a77cefd5372a'
down_revision: Union[str, None] = '15f76627bb42'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Add column as nullable first
    op.add_column('elements', sa.Column('descendants_count', sa.Integer(), nullable=True, comment='counter cache for total descendants (children + grandchildren + etc)'))
    
    # Set default value for existing rows
    op.execute("UPDATE elements SET descendants_count = 0 WHERE descendants_count IS NULL")
    
    # Now make it NOT NULL
    op.alter_column('elements', 'descendants_count', nullable=False)
    
    op.drop_column('elements', 'children_count')
    op.execute("""CREATE OR REPLACE FUNCTION "rebuild_element_tree"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node_rec RECORD;
    BEGIN
        -- Reset all tree fields
        UPDATE elements
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Create temporary stack table
        CREATE TEMP TABLE IF NOT EXISTS node_stack (
            stack_order serial,
            node_id integer,
            node_level integer,
            action text -- 'enter' or 'exit'
        ) ON COMMIT DROP;

        -- Clear any existing data
        DELETE FROM node_stack;

        -- Push all root nodes onto stack (in reverse order for proper LIFO)
        -- Root nodes have both parent_id IS NULL and document_id IS NOT NULL
        INSERT INTO node_stack (node_id, node_level, action)
        SELECT id, 0, 'enter'
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        ORDER BY id DESC;

        -- Process stack until empty using proper DFS
        WHILE EXISTS (SELECT 1 FROM node_stack) LOOP
            -- Pop top item from stack
            SELECT node_id, node_level, action, stack_order
            INTO node_rec
            FROM node_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM node_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                -- Set left value and level
                UPDATE elements
                SET "left" = counter, level = node_rec.node_level
                WHERE id = node_rec.node_id;
                counter := counter + 1;

                -- Push exit action for this node
                INSERT INTO node_stack (node_id, node_level, action)
                VALUES (node_rec.node_id, node_rec.node_level, 'exit');

                -- Push enter actions for all children (in reverse order for LIFO)
                INSERT INTO node_stack (node_id, node_level, action)
                SELECT id, node_rec.node_level + 1, 'enter'
                FROM elements
                WHERE parent_id = node_rec.node_id
                ORDER BY id DESC;

            ELSE -- action = 'exit'
                -- Set right value
                UPDATE elements
                SET "right" = counter
                WHERE id = node_rec.node_id;
                counter := counter + 1;
            END IF;
        END LOOP;

        -- Update children_count
        UPDATE elements e
        SET children_count = COALESCE(c.cnt, 0)
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;

        -- Update position within siblings
        WITH sibling_groups AS (
            SELECT
                id,
                parent_id,
                ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM elements
            WHERE parent_id IS NOT NULL
        )
        UPDATE elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_nested_set_simple"();""")
    op.execute("""DROP FUNCTION IF EXISTS "debug_tree_rebuild_v2"();""")
    op.execute("""DROP FUNCTION IF EXISTS "debug_tree_rebuild_v3"();""")
    op.execute("""DROP FUNCTION IF EXISTS "generate_nested_set_cte"();""")
    op.execute("""DROP FUNCTION IF EXISTS "calculate_element_nested_set"();""")
    op.execute("""DROP FUNCTION IF EXISTS "complete_nested_set_calculation"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_tree_rebuild"();""")
    op.execute("""DROP FUNCTION IF EXISTS "debug_tree_rebuild"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_subtree"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_direct_update"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_with_debug"();""")
    op.execute("""DROP FUNCTION IF EXISTS "fast_nested_set_calc"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_update_with_commit"();""")
    op.execute("""DROP FUNCTION IF EXISTS "generate_nested_set_simple"();""")
    op.execute("""DROP FUNCTION IF EXISTS "element_tree_stats"();""")
    op.execute("""DROP FUNCTION IF EXISTS "apply_nested_set_values"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_simple_update"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_subtree_v2"();""")
    op.execute("""DROP FUNCTION IF EXISTS "complete_nested_set_calc"();""")
    op.execute("""DROP FUNCTION IF EXISTS "apply_element_nested_set"();""")
    op.execute("""DROP FUNCTION IF EXISTS "accurate_nested_set_calc"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_debug"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_new"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_subtree_debug"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_update_element"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_update_position"();""")
    op.execute("""DROP FUNCTION IF EXISTS "correct_nested_set_calc"();""")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute("""CREATE FUNCTION "correct_nested_set_calc"() RETURNS record LANGUAGE sql AS $$
    WITH RECURSIVE tree_with_counts AS (
        -- Start with root nodes
        SELECT
            e.id,
            e.parent_id,
            0 as level,
            ROW_NUMBER() OVER (ORDER BY COALESCE(e.position, 0), e.id) - 1 as position_val,
            ARRAY[COALESCE(e.position, 0), e.id] as sort_path
        FROM elements e
        WHERE e.parent_id IS NULL

        UNION ALL

        -- Add children recursively
        SELECT
            e.id,
            e.parent_id,
            t.level + 1,
            ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY COALESCE(e.position, 0), e.id) - 1 as position_val,
            t.sort_path || ARRAY[COALESCE(e.position, 0), e.id] as sort_path
        FROM elements e
        INNER JOIN tree_with_counts t ON e.parent_id = t.id
    ),
    -- Count children for each node
    children_counts AS (
        SELECT
            COALESCE(parent_id, 0) as parent_id,
            COUNT(*) as children_count
        FROM elements
        GROUP BY parent_id
    ),
    -- Calculate subtree node counts
    subtree_counts AS (
        SELECT
            t.id,
            t.parent_id,
            t.level,
            t.position_val,
            t.sort_path,
            COALESCE(cc.children_count, 0) as direct_children,
            -- Count total nodes in subtree including self
            (SELECT COUNT(*)
             FROM tree_with_counts t2
             WHERE t2.sort_path[1:array_length(t.sort_path,1)] = t.sort_path) as subtree_size
        FROM tree_with_counts t
        LEFT JOIN children_counts cc ON t.id = cc.parent_id
    ),
    -- Assign left values using DFS ordering
    with_left_values AS (
        SELECT
            *,
            ROW_NUMBER() OVER (ORDER BY sort_path) as dfs_order
        FROM subtree_counts
    )
    SELECT
        id as element_id,
        parent_id as element_parent_id,
        level as tree_level,
        position_val,
        dfs_order * 2 - 1 as left_val,
        (dfs_order * 2 - 1) + (subtree_size - 1) * 2 + 1 as right_val,
        direct_children as children_count
    FROM with_left_values
    ORDER BY left_val;
    $$;""")
    op.execute("""CREATE FUNCTION "test_update_position"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
        old_pos INTEGER;
        new_pos INTEGER;
    BEGIN
        -- Get current position
        SELECT position INTO old_pos FROM elements WHERE id = element_id;

        -- Update position
        UPDATE elements
        SET position = 999
        WHERE id = element_id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;

        -- Get new position
        SELECT position INTO new_pos FROM elements WHERE id = element_id;

        RETURN 'Old: ' || old_pos || ', New: ' || new_pos || ', Updated: ' || updated_count;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_update_element"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        result_text TEXT;
    BEGIN
        UPDATE elements
        SET level = 999
        WHERE id = element_id;

        SELECT 'Updated element ' || element_id || ' level to ' || level
        INTO result_text
        FROM elements
        WHERE id = element_id;

        RETURN result_text;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_subtree_debug"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
        RETURN QUERY
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                id::text as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.parent_id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        SELECT
            fv.id::INTEGER,
            fv.level::INTEGER,
            fv.position::INTEGER,
            fv.left_val::INTEGER,
            fv.right_val::INTEGER,
            fv.children_count::INTEGER
        FROM final_values fv
        ORDER BY fv.left_val;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_new"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        root_element RECORD;
    BEGIN
        -- Process each root element (those with parent_id IS NULL)
        FOR root_element IN
            SELECT id FROM elements WHERE parent_id IS NULL ORDER BY id
        LOOP
            PERFORM rebuild_element_subtree(root_element.id);
        END LOOP;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_debug"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node_rec RECORD;
        initial_count integer;
        stack_count integer;
        iterations integer := 0;
    BEGIN
        -- Check initial root count
        SELECT COUNT(*) INTO initial_count
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL;

        -- Reset all tree fields
        UPDATE elements
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Create temporary stack table
        CREATE TEMP TABLE IF NOT EXISTS node_stack (
            stack_order serial,
            node_id integer,
            node_level integer,
            action text
        ) ON COMMIT DROP;

        DELETE FROM node_stack;

        -- Push all root nodes onto stack
        INSERT INTO node_stack (node_id, node_level, action)
        SELECT id, 0, 'enter'
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        ORDER BY id DESC;

        SELECT COUNT(*) INTO stack_count FROM node_stack;

        -- Process stack with iteration limit
        WHILE EXISTS (SELECT 1 FROM node_stack) AND iterations < 10 LOOP
            iterations := iterations + 1;

            SELECT node_id, node_level, action, stack_order
            INTO node_rec
            FROM node_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM node_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                UPDATE elements
                SET "left" = counter, level = node_rec.node_level
                WHERE id = node_rec.node_id;
                counter := counter + 1;

                INSERT INTO node_stack (node_id, node_level, action)
                VALUES (node_rec.node_id, node_rec.node_level, 'exit');

                INSERT INTO node_stack (node_id, node_level, action)
                SELECT id, node_rec.node_level + 1, 'enter'
                FROM elements
                WHERE parent_id = node_rec.node_id
                ORDER BY id DESC;

            ELSE
                UPDATE elements
                SET "right" = counter
                WHERE id = node_rec.node_id;
                counter := counter + 1;
            END IF;
        END LOOP;

        RETURN 'Initial roots: ' || initial_count ||
               ', Stack size: ' || stack_count ||
               ', Iterations: ' || iterations ||
               ', Final counter: ' || counter;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "accurate_nested_set_calc"() RETURNS record LANGUAGE sql AS $$
    WITH RECURSIVE tree_traversal AS (
        -- Root nodes (no parent) - ordered by position, then id
        SELECT
            e.id as element_id,
            e.parent_id as element_parent_id,
            0 as tree_level,
            ROW_NUMBER() OVER (ORDER BY COALESCE(e.position, 0), e.id) - 1 as position_val,
            ARRAY[COALESCE(e.position, 0), e.id] as sort_path,
            1 as depth
        FROM elements e
        WHERE e.parent_id IS NULL

        UNION ALL

        -- Children nodes - ordered by position within each parent
        SELECT
            e.id as element_id,
            e.parent_id as element_parent_id,
            t.tree_level + 1 as tree_level,
            ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY COALESCE(e.position, 0), e.id) - 1 as position_val,
            t.sort_path || ARRAY[COALESCE(e.position, 0), e.id] as sort_path,
            t.depth + 1 as depth
        FROM elements e
        INNER JOIN tree_traversal t ON e.parent_id = t.element_id
    ),
    -- Calculate children counts
    children_counts AS (
        SELECT
            e.id as element_id,
            COUNT(c.id) as children_count
        FROM elements e
        LEFT JOIN elements c ON c.parent_id = e.id
        GROUP BY e.id
    ),
    -- Order nodes for DFS traversal (pre-order)
    dfs_ordered AS (
        SELECT
            tt.element_id,
            tt.element_parent_id,
            tt.tree_level,
            tt.position_val,
            cc.children_count,
            ROW_NUMBER() OVER (ORDER BY tt.sort_path) as visit_order
        FROM tree_traversal tt
        JOIN children_counts cc ON tt.element_id = cc.element_id
    ),
    -- Calculate nested set left values and descendant counts
    with_descendants AS (
        SELECT
            do1.*,
            -- Count all descendants (nodes that come after this one in the subtree)
            COALESCE((
                SELECT COUNT(*)
                FROM tree_traversal tt1
                JOIN tree_traversal tt2 ON tt2.element_id = do1.element_id
                WHERE array_length(tt1.sort_path, 1) > array_length(tt2.sort_path, 1)
                AND tt1.sort_path[1:array_length(tt2.sort_path, 1)] = tt2.sort_path
            ), 0) as descendant_count
        FROM dfs_ordered do1
    )
    SELECT
        element_id,
        element_parent_id,
        tree_level,
        position_val,
        -- Left value: pre-order visit number * 2 - 1
        (visit_order * 2 - 1) as left_val,
        -- Right value: left + (descendant_count * 2) + 1
        (visit_order * 2 - 1) + (descendant_count * 2) + 1 as right_val,
        children_count
    FROM with_descendants
    ORDER BY left_val;
    $$;""")
    op.execute("""CREATE FUNCTION "apply_element_nested_set"() RETURNS int4 LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
    BEGIN
        -- Use the calculation function to update the elements table
        UPDATE elements
        SET
            position = calc.element_position,
            level = calc.element_level,
            "left" = calc.left_val,
            "right" = calc.right_val,
            children_count = calc.child_count
        FROM calculate_element_nested_set(root_element_id) calc
        WHERE elements.id = calc.element_id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;
        RETURN updated_count;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "complete_nested_set_calc"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
      RETURN QUERY
      WITH RECURSIVE tree_cte AS (
        SELECT
          e.id,
          e.parent_id,
          0 as level,
          ARRAY[e.id] as path
        FROM elements e
        WHERE e.parent_id IS NULL AND e.document_id IS NOT NULL

        UNION ALL

        SELECT
          e.id,
          e.parent_id,
          t.level + 1,
          t.path || e.id
        FROM elements e
        JOIN tree_cte t ON e.parent_id = t.id
        WHERE t.level < 3
      )
      SELECT
        t.id as element_id,
        t.parent_id as element_parent_id,
        t.level as tree_level,
        (ROW_NUMBER() OVER (PARTITION BY t.parent_id ORDER BY t.id) - 1)::integer as position_val,
        (ROW_NUMBER() OVER (ORDER BY t.path) * 2 - 1)::integer as left_val,
        (ROW_NUMBER() OVER (ORDER BY t.path) * 2)::integer as right_val,
        COALESCE((SELECT COUNT(*)::integer FROM tree_cte t2 WHERE t2.parent_id = t.id), 0) as children_count
      FROM tree_cte t
      ORDER BY t.path;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_subtree_v2"() RETURNS int4 LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
    BEGIN
        -- Update all nested set values for the subtree in a single operation
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                LPAD(0::text, 10, '0') as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.parent_id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        -- Step 6: Update the elements table and count affected rows
        UPDATE elements
        SET
            position = fv.position,
            level = fv.level,
            "left" = fv.left_val,
            "right" = fv.right_val,
            children_count = fv.children_count
        FROM final_values fv
        WHERE elements.id = fv.id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;
        RETURN updated_count;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_simple_update"() RETURNS void LANGUAGE plpgsql AS $$
    BEGIN
        UPDATE elements SET "left" = 999 WHERE id = 1;
        UPDATE elements SET "right" = 888 WHERE id = 1;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "apply_nested_set_values"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        update_count INTEGER;
    BEGIN
        -- Update all elements with calculated nested set values
        WITH calc AS (
            SELECT * FROM accurate_nested_set_calc()
        )
        UPDATE elements
        SET
            "left" = calc.left_val,
            "right" = calc.right_val,
            "level" = calc.tree_level,
            "position" = calc.position_val,
            children_count = calc.children_count
        FROM calc
        WHERE elements.id = calc.element_id;

        GET DIAGNOSTICS update_count = ROW_COUNT;

        RETURN 'Updated ' || update_count || ' elements with nested set values';
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "element_tree_stats"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
        RETURN QUERY
        WITH tree_analysis AS (
            SELECT
                COUNT(*) as total,
                MAX(level) as max_level,
                COUNT(*) FILTER (WHERE parent_id IS NULL) as roots,
                COUNT(*) FILTER (WHERE parent_id IS NOT NULL AND NOT EXISTS (
                    SELECT 1 FROM elements p WHERE p.id = elements.parent_id
                )) as orphaned,
                -- Check nested set integrity (left < right, no overlaps within same parent)
                BOOL_AND(
                    "left" IS NOT NULL AND
                    "right" IS NOT NULL AND
                    "left" < "right" AND
                    "left" > 0 AND
                    "right" > 0
                ) as integrity
            FROM elements
            WHERE CASE
                WHEN root_element_id IS NOT NULL THEN
                    id IN (
                        WITH RECURSIVE subtree AS (
                            SELECT id FROM elements WHERE id = root_element_id
                            UNION ALL
                            SELECT e.id FROM elements e
                            INNER JOIN subtree s ON e.parent_id = s.id
                        )
                        SELECT id FROM subtree
                    )
                ELSE TRUE
            END
        )
        SELECT
            total::INTEGER,
            max_level::INTEGER,
            roots::INTEGER,
            orphaned::INTEGER,
            integrity
        FROM tree_analysis;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "generate_nested_set_simple"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
      RETURN QUERY
      SELECT
        e.id as element_id,
        0 as tree_level,
        (ROW_NUMBER() OVER (ORDER BY e.id) * 2 - 1)::integer as left_val,
        (ROW_NUMBER() OVER (ORDER BY e.id) * 2)::integer as right_val
      FROM elements e
      WHERE e.parent_id IS NULL AND e.document_id IS NOT NULL
      ORDER BY e.id
      LIMIT 5;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_update_with_commit"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
        current_left INTEGER;
    BEGIN
        -- Check current value
        SELECT "left" INTO current_left FROM elements WHERE id = element_id;

        -- Update
        UPDATE elements
        SET "left" = 999, "right" = 888, level = 7
        WHERE id = element_id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;

        -- Force commit within function (this will fail if not allowed)
        COMMIT;

        RETURN 'Before: ' || COALESCE(current_left::text, 'NULL') || ', Updated: ' || updated_count || ' rows';

    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'Error: ' || SQLERRM;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "fast_nested_set_calc"() RETURNS record LANGUAGE sql AS $$
    WITH RECURSIVE tree_traversal AS (
        -- Root nodes (no parent) - ordered by position, then id
        SELECT
            e.id as element_id,
            e.parent_id as element_parent_id,
            0 as tree_level,
            ROW_NUMBER() OVER (ORDER BY COALESCE(e.position, 0), e.id) - 1 as position_val,
            ARRAY[e.id] as path,
            1 as node_count
        FROM elements e
        WHERE e.parent_id IS NULL

        UNION ALL

        -- Children nodes - ordered by position within each parent
        SELECT
            e.id as element_id,
            e.parent_id as element_parent_id,
            t.tree_level + 1 as tree_level,
            ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY COALESCE(e.position, 0), e.id) - 1 as position_val,
            t.path || e.id as path,
            1 as node_count
        FROM elements e
        INNER JOIN tree_traversal t ON e.parent_id = t.element_id
    ),
    -- Calculate children counts efficiently
    children_counts AS (
        SELECT
            parent_id,
            COUNT(*) as children_count
        FROM elements
        WHERE parent_id IS NOT NULL
        GROUP BY parent_id
    ),
    -- Add children counts to all nodes
    nodes_with_children AS (
        SELECT
            tt.element_id,
            tt.element_parent_id,
            tt.tree_level,
            tt.position_val,
            tt.path,
            COALESCE(cc.children_count, 0) as children_count
        FROM tree_traversal tt
        LEFT JOIN children_counts cc ON tt.element_id = cc.parent_id
    ),
    -- Calculate visit order and use simple formula for nested set values
    final_calc AS (
        SELECT
            element_id,
            element_parent_id,
            tree_level,
            position_val,
            children_count,
            ROW_NUMBER() OVER (ORDER BY path) as visit_order
        FROM nodes_with_children
    )
    SELECT
        element_id,
        element_parent_id,
        tree_level,
        position_val,
        visit_order * 2 - 1 as left_val,
        visit_order * 2 as right_val,
        children_count
    FROM final_calc
    ORDER BY left_val;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_with_debug"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node_rec RECORD;
        result_text text := '';
        test_count integer;
    BEGIN
        -- Reset all tree fields
        UPDATE elements
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        result_text := 'Reset all fields' || E'\n';

        -- Create temporary stack table
        CREATE TEMP TABLE IF NOT EXISTS node_stack (
            stack_order serial,
            node_id integer,
            node_level integer,
            action text -- 'enter' or 'exit'
        ) ON COMMIT DROP;

        -- Clear any existing data
        DELETE FROM node_stack;

        -- Push first 3 root nodes only for testing
        INSERT INTO node_stack (node_id, node_level, action)
        SELECT id, 0, 'enter'
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        ORDER BY id DESC
        LIMIT 3;

        SELECT COUNT(*) INTO test_count FROM node_stack;
        result_text := result_text || 'Stack initialized with ' || test_count || ' nodes' || E'\n';

        -- Process stack until empty using proper DFS
        WHILE EXISTS (SELECT 1 FROM node_stack) LOOP
            -- Pop top item from stack
            SELECT node_id, node_level, action, stack_order
            INTO node_rec
            FROM node_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM node_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                -- Set left value and level
                UPDATE elements
                SET "left" = counter, level = node_rec.node_level
                WHERE id = node_rec.node_id;

                result_text := result_text || 'Set left=' || counter || ' for node ' || node_rec.node_id || E'\n';
                counter := counter + 1;

                -- Push exit action for this node
                INSERT INTO node_stack (node_id, node_level, action)
                VALUES (node_rec.node_id, node_rec.node_level, 'exit');

                -- Push enter actions for all children (in reverse order for LIFO)
                INSERT INTO node_stack (node_id, node_level, action)
                SELECT id, node_rec.node_level + 1, 'enter'
                FROM elements
                WHERE parent_id = node_rec.node_id
                ORDER BY id DESC;

            ELSE -- action = 'exit'
                -- Set right value
                UPDATE elements
                SET "right" = counter
                WHERE id = node_rec.node_id;

                result_text := result_text || 'Set right=' || counter || ' for node ' || node_rec.node_id || E'\n';
                counter := counter + 1;
            END IF;
        END LOOP;

        -- Check results within the same transaction
        SELECT COUNT(*) INTO test_count FROM elements WHERE "left" IS NOT NULL;
        result_text := result_text || 'Final: ' || test_count || ' nodes have left values' || E'\n';

        RETURN result_text;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_direct_update"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        result TEXT;
    BEGIN
        UPDATE elements
        SET "left" = 999, "right" = 1000
        WHERE id = element_id;

        SELECT '"left": ' || COALESCE("left"::text, 'NULL') || ', "right": ' || COALESCE("right"::text, 'NULL')
        INTO result
        FROM elements
        WHERE id = element_id;

        RETURN result;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_subtree"() RETURNS void LANGUAGE plpgsql AS $$
    BEGIN
        -- Update all nested set values for the subtree in a single operation
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                id::text as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.parent_id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        -- Step 6: Update the elements table
        UPDATE elements
        SET
            position = fv.position,
            level = fv.level,
            "left" = fv.left_val,
            "right" = fv.right_val,
            children_count = fv.children_count
        FROM final_values fv
        WHERE elements.id = fv.id;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "debug_tree_rebuild"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        root_count integer;
        test_id integer;
        result_text text := '';
    BEGIN
        -- Check how many root nodes we have
        SELECT COUNT(*) INTO root_count
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL;

        result_text := 'Root nodes found: ' || root_count || E'\n';

        -- Get one test node ID
        SELECT id INTO test_id
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        LIMIT 1;

        result_text := result_text || 'Test node ID: ' || test_id || E'\n';

        -- Try to update just one node directly
        UPDATE elements
        SET "left" = 1, "right" = 2, level = 0
        WHERE id = test_id;

        -- Check if the update worked
        IF FOUND THEN
            result_text := result_text || 'Direct update successful' || E'\n';
        ELSE
            result_text := result_text || 'Direct update failed' || E'\n';
        END IF;

        RETURN result_text;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_tree_rebuild"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node_rec RECORD;
        test_node_id integer;
    BEGIN
        -- Test with just one document
        SELECT id INTO test_node_id FROM elements WHERE parent_id IS NULL AND document_id IS NOT NULL LIMIT 1;

        -- Reset this node
        UPDATE elements SET "left" = NULL, "right" = NULL, level = 0 WHERE id = test_node_id;

        -- Set simple values
        UPDATE elements SET "left" = 1, "right" = 2, level = 0 WHERE id = test_node_id;

        RAISE NOTICE 'Updated node % with left=1, right=2, level=0', test_node_id;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "complete_nested_set_calculation"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
      RETURN QUERY
      WITH RECURSIVE tree_cte AS (
        SELECT
          e.id,
          e.parent_id,
          0 as level,
          ARRAY[e.id] as path
        FROM elements e
        WHERE e.parent_id IS NULL AND e.document_id IS NOT NULL

        UNION ALL

        SELECT
          e.id,
          e.parent_id,
          t.level + 1,
          t.path || e.id
        FROM elements e
        JOIN tree_cte t ON e.parent_id = t.id
        WHERE t.level < 3
      )
      SELECT
        id as element_id,
        parent_id,
        level as tree_level,
        (ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1)::integer as position_val,
        (ROW_NUMBER() OVER (ORDER BY path) * 2 - 1)::integer as left_val,
        (ROW_NUMBER() OVER (ORDER BY path) * 2)::integer as right_val,
        COALESCE((SELECT COUNT(*)::integer FROM tree_cte t2 WHERE t2.parent_id = tree_cte.id), 0) as children_count
      FROM tree_cte
      ORDER BY path;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "calculate_element_nested_set"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
        RETURN QUERY
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                LPAD(0::text, 10, '0') as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        SELECT
            fv.id::INTEGER as element_id,
            fv.level::INTEGER as element_level,
            fv.position::INTEGER as element_position,
            fv.left_val::INTEGER as left_val,
            fv.right_val::INTEGER as right_val,
            fv.children_count::INTEGER as child_count
        FROM final_values fv
        ORDER BY fv.left_val;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "generate_nested_set_cte"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
      RETURN QUERY
      WITH RECURSIVE tree_traversal AS (
        -- Base case: root nodes
        SELECT
          e.id as element_id,
          e.parent_id,
          e.document_id,
          e.type as element_type,
          0 as tree_level,
          ROW_NUMBER() OVER (ORDER BY e.id) * 2 - 1 as left_val,
          ROW_NUMBER() OVER (ORDER BY e.id) * 2 as right_val,
          0 as children_count,
          0 as position_val
        FROM elements e
        WHERE e.parent_id IS NULL AND e.document_id IS NOT NULL
        ORDER BY e.id
        LIMIT 5
      )
      SELECT * FROM tree_traversal;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "debug_tree_rebuild_v3"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        test_id integer;
        result_text text := '';
        left_val integer;
        right_val integer;
        level_val integer;
        update_count integer;
    BEGIN
        -- Get one test node ID
        SELECT id INTO test_id
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        LIMIT 1;

        result_text := 'Test node ID: ' || test_id || E'\n';

        -- Check current values
        SELECT "left", "right", level INTO left_val, right_val, level_val
        FROM elements WHERE id = test_id;

        result_text := result_text || 'Before: left=' || COALESCE(left_val::text, 'NULL') ||
                       ', right=' || COALESCE(right_val::text, 'NULL') ||
                       ', level=' || COALESCE(level_val::text, 'NULL') || E'\n';

        -- Try to update
        UPDATE elements
        SET "left" = 999, "right" = 1000, level = 5
        WHERE id = test_id;

        GET DIAGNOSTICS update_count = ROW_COUNT;
        result_text := result_text || 'Updated rows: ' || update_count || E'\n';

        -- Check values after update
        SELECT "left", "right", level INTO left_val, right_val, level_val
        FROM elements WHERE id = test_id;

        result_text := result_text || 'After: left=' || COALESCE(left_val::text, 'NULL') ||
                       ', right=' || COALESCE(right_val::text, 'NULL') ||
                       ', level=' || COALESCE(level_val::text, 'NULL') || E'\n';

        RETURN result_text;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "debug_tree_rebuild_v2"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        test_id integer;
        result_text text := '';
        left_val integer;
        right_val integer;
        level_val integer;
    BEGIN
        -- Get one test node ID
        SELECT id INTO test_id
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        LIMIT 1;

        result_text := 'Test node ID: ' || test_id || E'\n';

        -- Check current values
        SELECT "left", "right", level INTO left_val, right_val, level_val
        FROM elements WHERE id = test_id;

        result_text := result_text || 'Before: left=' || COALESCE(left_val::text, 'NULL') ||
                       ', right=' || COALESCE(right_val::text, 'NULL') ||
                       ', level=' || COALESCE(level_val::text, 'NULL') || E'\n';

        -- Try to update with explicit COMMIT
        UPDATE elements
        SET "left" = 999, "right" = 1000, level = 5
        WHERE id = test_id;

        result_text := result_text || 'Updated rows: ' || ROW_COUNT || E'\n';

        -- Check values after update
        SELECT "left", "right", level INTO left_val, right_val, level_val
        FROM elements WHERE id = test_id;

        result_text := result_text || 'After: left=' || COALESCE(left_val::text, 'NULL') ||
                       ', right=' || COALESCE(right_val::text, 'NULL') ||
                       ', level=' || COALESCE(level_val::text, 'NULL') || E'\n';

        RETURN result_text;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_nested_set_simple"() RETURNS record LANGUAGE plpgsql AS $$
    DECLARE
        counter INTEGER := 1;
        node_rec RECORD;
        stack_rec RECORD;
    BEGIN
        -- Create temp table to hold results
        CREATE TEMP TABLE IF NOT EXISTS nested_results (
            id INTEGER,
            level INTEGER,
            position INTEGER,
            left_val INTEGER,
            right_val INTEGER,
            child_count INTEGER
        ) ON COMMIT DROP;

        -- Create temp stack for DFS traversal
        CREATE TEMP TABLE IF NOT EXISTS dfs_stack (
            node_id INTEGER,
            node_level INTEGER,
            node_position INTEGER,
            action TEXT, -- 'enter' or 'exit'
            stack_order SERIAL
        ) ON COMMIT DROP;

        -- Clear any existing data
        TRUNCATE nested_results;
        TRUNCATE dfs_stack;

        -- Push root onto stack
        INSERT INTO dfs_stack (node_id, node_level, node_position, action)
        VALUES (root_element_id, 0, 0, 'enter');

        -- Process stack with proper DFS and counters
        WHILE EXISTS (SELECT 1 FROM dfs_stack) LOOP
            -- Pop from stack (LIFO)
            SELECT node_id, node_level, node_position, action, stack_order
            INTO node_rec
            FROM dfs_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM dfs_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                -- Assign left value and increment counter
                INSERT INTO nested_results (id, level, position, left_val, right_val, child_count)
                VALUES (node_rec.node_id, node_rec.node_level, node_rec.node_position, counter, 0, 0);

                counter := counter + 1;

                -- Push exit action for this node
                INSERT INTO dfs_stack (node_id, node_level, node_position, action)
                VALUES (node_rec.node_id, node_rec.node_level, node_rec.node_position, 'exit');

                -- Push enter actions for children (in reverse order for LIFO)
                INSERT INTO dfs_stack (node_id, node_level, node_position, action)
                SELECT
                    e.id,
                    node_rec.node_level + 1,
                    ROW_NUMBER() OVER (ORDER BY e.position, e.id) - 1,
                    'enter'
                FROM elements e
                WHERE e.parent_id = node_rec.node_id
                ORDER BY e.position DESC, e.id DESC; -- Reverse order for stack

            ELSE -- action = 'exit'
                -- Assign right value and increment counter
                UPDATE nested_results
                SET right_val = counter
                WHERE id = node_rec.node_id;

                counter := counter + 1;
            END IF;
        END LOOP;

        -- Calculate children counts
        UPDATE nested_results nr
        SET child_count = COALESCE((
            SELECT COUNT(*)
            FROM nested_results nr2
            WHERE nr2.level = nr.level + 1
            AND nr2.left_val > nr.left_val
            AND nr2.left_val < nr.right_val
        ), 0);

        -- Return results
        RETURN QUERY
        SELECT nr.id, nr.level, nr.position, nr.left_val, nr.right_val, nr.child_count
        FROM nested_results nr
        ORDER BY nr.left_val;

    END;
    $$;""")
    op.execute("""CREATE OR REPLACE FUNCTION "rebuild_element_tree"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node_rec RECORD;
    BEGIN
        -- Reset all tree fields
        UPDATE elements
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Create temporary stack table
        CREATE TEMP TABLE IF NOT EXISTS node_stack (
            stack_order serial,
            node_id integer,
            node_level integer,
            action text -- 'enter' or 'exit'
        ) ON COMMIT DROP;

        -- Clear any existing data
        DELETE FROM node_stack;

        -- Push all root nodes onto stack (in reverse order for proper LIFO)
        -- Root nodes have both parent_id IS NULL and document_id IS NOT NULL
        INSERT INTO node_stack (node_id, node_level, action)
        SELECT id, 0, 'enter'
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        ORDER BY id DESC;

        -- Process stack until empty using proper DFS
        WHILE EXISTS (SELECT 1 FROM node_stack) LOOP
            -- Pop top item from stack
            SELECT node_id, node_level, action, stack_order
            INTO node_rec
            FROM node_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM node_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                -- Set left value and level
                UPDATE elements
                SET "left" = counter, level = node_rec.node_level
                WHERE id = node_rec.node_id;
                counter := counter + 1;

                -- Push exit action for this node
                INSERT INTO node_stack (node_id, node_level, action)
                VALUES (node_rec.node_id, node_rec.node_level, 'exit');

                -- Push enter actions for all children (in reverse order for LIFO)
                INSERT INTO node_stack (node_id, node_level, action)
                SELECT id, node_rec.node_level + 1, 'enter'
                FROM elements
                WHERE parent_id = node_rec.node_id
                ORDER BY id DESC;

            ELSE -- action = 'exit'
                -- Set right value
                UPDATE elements
                SET "right" = counter
                WHERE id = node_rec.node_id;
                counter := counter + 1;
            END IF;
        END LOOP;

        -- Update children_count
        UPDATE elements e
        SET children_count = COALESCE(c.cnt, 0)
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;

        -- Update position within siblings
        WITH sibling_groups AS (
            SELECT
                id,
                parent_id,
                ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM elements
            WHERE parent_id IS NOT NULL
        )
        UPDATE elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.add_column('elements', sa.Column('children_count', sa.INTEGER(), autoincrement=False, nullable=False, comment='counter cache for len(self.children)'))
    op.drop_column('elements', 'descendants_count')
    # ### end Alembic commands ###
