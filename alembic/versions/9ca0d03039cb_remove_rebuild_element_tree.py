"""remove rebuild_element_tree

Revision ID: 9ca0d03039cb
Revises: a77cefd5372a
Create Date: 2025-08-02 23:26:38.321275

"""
from typing import Sequence, Union

import sqlalchemy as sa

from pgvector.sqlalchemy import Vector

from alembic import op


# revision identifiers, used by Alembic.
revision: str = '9ca0d03039cb'
down_revision: Union[str, None] = 'a77cefd5372a'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_subtree_v2"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree"();""")
    op.execute("""DROP FUNCTION IF EXISTS "apply_element_nested_set"();""")
    op.execute("""DROP FUNCTION IF EXISTS "calculate_element_nested_set"();""")
    op.execute("""DROP FUNCTION IF EXISTS "element_tree_stats"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_subtree"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_simple_update"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_nested_set_simple"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_update_element"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_update_with_commit"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_subtree_debug"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_update_position"();""")
    op.execute("""DROP FUNCTION IF EXISTS "test_direct_update"();""")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute("""CREATE FUNCTION "test_direct_update"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        result TEXT;
    BEGIN
        UPDATE elements
        SET "left" = 999, "right" = 1000
        WHERE id = element_id;

        SELECT '"left": ' || COALESCE("left"::text, 'NULL') || ', "right": ' || COALESCE("right"::text, 'NULL')
        INTO result
        FROM elements
        WHERE id = element_id;

        RETURN result;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_update_position"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
        old_pos INTEGER;
        new_pos INTEGER;
    BEGIN
        -- Get current position
        SELECT position INTO old_pos FROM elements WHERE id = element_id;

        -- Update position
        UPDATE elements
        SET position = 999
        WHERE id = element_id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;

        -- Get new position
        SELECT position INTO new_pos FROM elements WHERE id = element_id;

        RETURN 'Old: ' || old_pos || ', New: ' || new_pos || ', Updated: ' || updated_count;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_subtree_debug"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
        RETURN QUERY
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                id::text as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.parent_id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        SELECT
            fv.id::INTEGER,
            fv.level::INTEGER,
            fv.position::INTEGER,
            fv.left_val::INTEGER,
            fv.right_val::INTEGER,
            fv.children_count::INTEGER
        FROM final_values fv
        ORDER BY fv.left_val;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_update_with_commit"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
        current_left INTEGER;
    BEGIN
        -- Check current value
        SELECT "left" INTO current_left FROM elements WHERE id = element_id;

        -- Update
        UPDATE elements
        SET "left" = 999, "right" = 888, level = 7
        WHERE id = element_id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;

        -- Force commit within function (this will fail if not allowed)
        COMMIT;

        RETURN 'Before: ' || COALESCE(current_left::text, 'NULL') || ', Updated: ' || updated_count || ' rows';

    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'Error: ' || SQLERRM;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_update_element"() RETURNS text LANGUAGE plpgsql AS $$
    DECLARE
        result_text TEXT;
    BEGIN
        UPDATE elements
        SET level = 999
        WHERE id = element_id;

        SELECT 'Updated element ' || element_id || ' level to ' || level
        INTO result_text
        FROM elements
        WHERE id = element_id;

        RETURN result_text;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_nested_set_simple"() RETURNS record LANGUAGE plpgsql AS $$
    DECLARE
        counter INTEGER := 1;
        node_rec RECORD;
        stack_rec RECORD;
    BEGIN
        -- Create temp table to hold results
        CREATE TEMP TABLE IF NOT EXISTS nested_results (
            id INTEGER,
            level INTEGER,
            position INTEGER,
            left_val INTEGER,
            right_val INTEGER,
            child_count INTEGER
        ) ON COMMIT DROP;

        -- Create temp stack for DFS traversal
        CREATE TEMP TABLE IF NOT EXISTS dfs_stack (
            node_id INTEGER,
            node_level INTEGER,
            node_position INTEGER,
            action TEXT, -- 'enter' or 'exit'
            stack_order SERIAL
        ) ON COMMIT DROP;

        -- Clear any existing data
        TRUNCATE nested_results;
        TRUNCATE dfs_stack;

        -- Push root onto stack
        INSERT INTO dfs_stack (node_id, node_level, node_position, action)
        VALUES (root_element_id, 0, 0, 'enter');

        -- Process stack with proper DFS and counters
        WHILE EXISTS (SELECT 1 FROM dfs_stack) LOOP
            -- Pop from stack (LIFO)
            SELECT node_id, node_level, node_position, action, stack_order
            INTO node_rec
            FROM dfs_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM dfs_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                -- Assign left value and increment counter
                INSERT INTO nested_results (id, level, position, left_val, right_val, child_count)
                VALUES (node_rec.node_id, node_rec.node_level, node_rec.node_position, counter, 0, 0);

                counter := counter + 1;

                -- Push exit action for this node
                INSERT INTO dfs_stack (node_id, node_level, node_position, action)
                VALUES (node_rec.node_id, node_rec.node_level, node_rec.node_position, 'exit');

                -- Push enter actions for children (in reverse order for LIFO)
                INSERT INTO dfs_stack (node_id, node_level, node_position, action)
                SELECT
                    e.id,
                    node_rec.node_level + 1,
                    ROW_NUMBER() OVER (ORDER BY e.position, e.id) - 1,
                    'enter'
                FROM elements e
                WHERE e.parent_id = node_rec.node_id
                ORDER BY e.position DESC, e.id DESC; -- Reverse order for stack

            ELSE -- action = 'exit'
                -- Assign right value and increment counter
                UPDATE nested_results
                SET right_val = counter
                WHERE id = node_rec.node_id;

                counter := counter + 1;
            END IF;
        END LOOP;

        -- Calculate children counts
        UPDATE nested_results nr
        SET child_count = COALESCE((
            SELECT COUNT(*)
            FROM nested_results nr2
            WHERE nr2.level = nr.level + 1
            AND nr2.left_val > nr.left_val
            AND nr2.left_val < nr.right_val
        ), 0);

        -- Return results
        RETURN QUERY
        SELECT nr.id, nr.level, nr.position, nr.left_val, nr.right_val, nr.child_count
        FROM nested_results nr
        ORDER BY nr.left_val;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "test_simple_update"() RETURNS int4 LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
    BEGIN
        WITH simple_cte AS (
            SELECT id, 1 as new_left, 2 as new_right
            FROM elements
            WHERE id = root_element_id
        )
        UPDATE elements
        SET
            "left" = sc.new_left,
            "right" = sc.new_right
        FROM simple_cte sc
        WHERE elements.id = sc.id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;
        RETURN updated_count;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_subtree"() RETURNS void LANGUAGE plpgsql AS $$
    BEGIN
        -- Update all nested set values for the subtree in a single operation
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                id::text as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.parent_id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        -- Step 6: Update the elements table
        UPDATE elements
        SET
            position = fv.position,
            level = fv.level,
            "left" = fv.left_val,
            "right" = fv.right_val,
            children_count = fv.children_count
        FROM final_values fv
        WHERE elements.id = fv.id;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "element_tree_stats"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
        RETURN QUERY
        WITH tree_analysis AS (
            SELECT
                COUNT(*) as total,
                MAX(level) as max_level,
                COUNT(*) FILTER (WHERE parent_id IS NULL) as roots,
                COUNT(*) FILTER (WHERE parent_id IS NOT NULL AND NOT EXISTS (
                    SELECT 1 FROM elements p WHERE p.id = elements.parent_id
                )) as orphaned,
                -- Check nested set integrity (left < right, no overlaps within same parent)
                BOOL_AND(
                    "left" IS NOT NULL AND
                    "right" IS NOT NULL AND
                    "left" < "right" AND
                    "left" > 0 AND
                    "right" > 0
                ) as integrity
            FROM elements
            WHERE CASE
                WHEN root_element_id IS NOT NULL THEN
                    id IN (
                        WITH RECURSIVE subtree AS (
                            SELECT id FROM elements WHERE id = root_element_id
                            UNION ALL
                            SELECT e.id FROM elements e
                            INNER JOIN subtree s ON e.parent_id = s.id
                        )
                        SELECT id FROM subtree
                    )
                ELSE TRUE
            END
        )
        SELECT
            total::INTEGER,
            max_level::INTEGER,
            roots::INTEGER,
            orphaned::INTEGER,
            integrity
        FROM tree_analysis;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "calculate_element_nested_set"() RETURNS record LANGUAGE plpgsql AS $$
    BEGIN
        RETURN QUERY
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                LPAD(0::text, 10, '0') as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        SELECT
            fv.id::INTEGER as element_id,
            fv.level::INTEGER as element_level,
            fv.position::INTEGER as element_position,
            fv.left_val::INTEGER as left_val,
            fv.right_val::INTEGER as right_val,
            fv.children_count::INTEGER as child_count
        FROM final_values fv
        ORDER BY fv.left_val;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "apply_element_nested_set"() RETURNS int4 LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
    BEGIN
        -- Use the calculation function to update the elements table
        UPDATE elements
        SET
            position = calc.element_position,
            level = calc.element_level,
            "left" = calc.left_val,
            "right" = calc.right_val,
            children_count = calc.child_count
        FROM calculate_element_nested_set(root_element_id) calc
        WHERE elements.id = calc.element_id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;
        RETURN updated_count;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree"() RETURNS void LANGUAGE plpgsql AS $$
        DECLARE
            counter integer := 1;
            node_rec RECORD;
        BEGIN
            -- Reset all tree fields
            UPDATE elements
            SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

            -- Create temporary stack table
            CREATE TEMP TABLE IF NOT EXISTS node_stack (
                stack_order serial,
                node_id integer,
                node_level integer,
                action text -- 'enter' or 'exit'
            ) ON COMMIT DROP;

            -- Clear any existing data
            DELETE FROM node_stack;

            -- Push all root nodes onto stack (in reverse order for proper LIFO)
            -- Root nodes have both parent_id IS NULL and document_id IS NOT NULL
            INSERT INTO node_stack (node_id, node_level, action)
            SELECT id, 0, 'enter'
            FROM elements
            WHERE parent_id IS NULL AND document_id IS NOT NULL
            ORDER BY id DESC;

            -- Process stack until empty using proper DFS
            WHILE EXISTS (SELECT 1 FROM node_stack) LOOP
                -- Pop top item from stack
                SELECT node_id, node_level, action, stack_order
                INTO node_rec
                FROM node_stack
                ORDER BY stack_order DESC
                LIMIT 1;

                DELETE FROM node_stack WHERE stack_order = node_rec.stack_order;

                IF node_rec.action = 'enter' THEN
                    -- Set left value and level
                    UPDATE elements
                    SET "left" = counter, level = node_rec.node_level
                    WHERE id = node_rec.node_id;
                    counter := counter + 1;

                    -- Push exit action for this node
                    INSERT INTO node_stack (node_id, node_level, action)
                    VALUES (node_rec.node_id, node_rec.node_level, 'exit');

                    -- Push enter actions for all children (in reverse order for LIFO)
                    INSERT INTO node_stack (node_id, node_level, action)
                    SELECT id, node_rec.node_level + 1, 'enter'
                    FROM elements
                    WHERE parent_id = node_rec.node_id
                    ORDER BY id DESC;

                ELSE -- action = 'exit'
                    -- Set right value
                    UPDATE elements
                    SET "right" = counter
                    WHERE id = node_rec.node_id;
                    counter := counter + 1;
                END IF;
            END LOOP;

            -- Update children_count
            UPDATE elements e
            SET children_count = COALESCE(c.cnt, 0)
            FROM (
                SELECT parent_id, COUNT(*) AS cnt
                FROM elements
                WHERE parent_id IS NOT NULL
                GROUP BY parent_id
            ) c
            WHERE e.id = c.parent_id;

            -- Update position within siblings
            WITH sibling_groups AS (
                SELECT
                    id,
                    parent_id,
                    ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
                FROM elements
                WHERE parent_id IS NOT NULL
            )
            UPDATE elements e
            SET position = s.new_position
            FROM sibling_groups s
            WHERE e.id = s.id;
        END;
        $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_subtree_v2"() RETURNS int4 LANGUAGE plpgsql AS $$
    DECLARE
        updated_count INTEGER;
    BEGIN
        -- Update all nested set values for the subtree in a single operation
        WITH RECURSIVE

        -- Step 1: Build the complete tree structure with positions
        element_hierarchy AS (
            -- Root element
            SELECT
                id,
                parent_id,
                0 as level,
                0::bigint as position,
                ARRAY[id] as path,
                LPAD(0::text, 10, '0') as sort_path
            FROM elements
            WHERE id = root_element_id

            UNION ALL

            -- Recursive: get children ordered by position, then id for consistency
            SELECT
                e.id,
                e.parent_id,
                eh.level + 1,
                (ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id) - 1)::bigint,
                eh.path || e.id,
                eh.sort_path || '.' || LPAD((ROW_NUMBER() OVER (PARTITION BY e.parent_id ORDER BY e.position, e.id))::text, 10, '0')
            FROM elements e
            INNER JOIN element_hierarchy eh ON e.parent_id = eh.id
            WHERE NOT (e.id = ANY(eh.path))  -- Prevent cycles
        ),

        -- Step 2: Assign left values using pre-order traversal
        left_assignments AS (
            SELECT
                id,
                parent_id,
                level,
                position::integer,
                path,
                ROW_NUMBER() OVER (ORDER BY sort_path) as left_val
            FROM element_hierarchy
        ),

        -- Step 3: Calculate children counts
        children_counts AS (
            SELECT
                parent_id,
                COUNT(*) as child_count
            FROM element_hierarchy
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ),

        -- Step 4: Calculate right values using descendant count
        descendant_counts AS (
            SELECT
                la1.id,
                COUNT(la2.id) - 1 as descendant_count  -- Subtract 1 to exclude self
            FROM left_assignments la1
            LEFT JOIN left_assignments la2 ON la2.path @> ARRAY[la1.id]
            GROUP BY la1.id
        ),

        -- Step 5: Final calculations
        final_values AS (
            SELECT
                la.id,
                la.parent_id,
                la.level,
                la.position,
                la.left_val,
                la.left_val + (2 * dc.descendant_count) + 1 as right_val,
                COALESCE(cc.child_count, 0) as children_count
            FROM left_assignments la
            LEFT JOIN children_counts cc ON la.id = cc.parent_id
            LEFT JOIN descendant_counts dc ON la.id = dc.id
        )

        -- Step 6: Update the elements table and count affected rows
        UPDATE elements
        SET
            position = fv.position,
            level = fv.level,
            "left" = fv.left_val,
            "right" = fv.right_val,
            children_count = fv.children_count
        FROM final_values fv
        WHERE elements.id = fv.id;

        GET DIAGNOSTICS updated_count = ROW_COUNT;
        RETURN updated_count;

    END;
    $$;""")
    # ### end Alembic commands ###
