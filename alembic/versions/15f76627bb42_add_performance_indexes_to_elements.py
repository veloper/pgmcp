"""add_performance_indexes_to_elements

Revision ID: 15f76627bb42
Revises: e76237f88175
Create Date: 2025-08-02 14:58:05.495565

"""
from typing import Sequence, Union

import sqlalchemy as sa

from pgvector.sqlalchemy import Vector

from alembic import op


# revision identifiers, used by Alembic.
revision: str = '15f76627bb42'
down_revision: Union[str, None] = 'e76237f88175'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_index('idx_elements_parent_id', 'elements', ['parent_id'], unique=False)
    op.create_index('idx_elements_sibling_order', 'elements', ['parent_id', 'id'], unique=False)
    op.execute("""CREATE OR REPLACE FUNCTION "rebuild_element_tree"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node_rec RECORD;
    BEGIN
        -- Reset all tree fields
        UPDATE elements
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Create temporary stack table
        CREATE TEMP TABLE IF NOT EXISTS node_stack (
            stack_order serial,
            node_id integer,
            node_level integer,
            action text -- 'enter' or 'exit'
        ) ON COMMIT DROP;

        -- Clear any existing data
        DELETE FROM node_stack;

        -- Push all root nodes onto stack (in reverse order for proper LIFO)
        -- Root nodes have both parent_id IS NULL and document_id IS NOT NULL
        INSERT INTO node_stack (node_id, node_level, action)
        SELECT id, 0, 'enter'
        FROM elements
        WHERE parent_id IS NULL AND document_id IS NOT NULL
        ORDER BY id DESC;

        -- Process stack until empty using proper DFS
        WHILE EXISTS (SELECT 1 FROM node_stack) LOOP
            -- Pop top item from stack
            SELECT node_id, node_level, action, stack_order
            INTO node_rec
            FROM node_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM node_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                -- Set left value and level
                UPDATE elements
                SET "left" = counter, level = node_rec.node_level
                WHERE id = node_rec.node_id;
                counter := counter + 1;

                -- Push exit action for this node
                INSERT INTO node_stack (node_id, node_level, action)
                VALUES (node_rec.node_id, node_rec.node_level, 'exit');

                -- Push enter actions for all children (in reverse order for LIFO)
                INSERT INTO node_stack (node_id, node_level, action)
                SELECT id, node_rec.node_level + 1, 'enter'
                FROM elements
                WHERE parent_id = node_rec.node_id
                ORDER BY id DESC;

            ELSE -- action = 'exit'
                -- Set right value
                UPDATE elements
                SET "right" = counter
                WHERE id = node_rec.node_id;
                counter := counter + 1;
            END IF;
        END LOOP;

        -- Update children_count
        UPDATE elements e
        SET children_count = COALESCE(c.cnt, 0)
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;

        -- Update position within siblings
        WITH sibling_groups AS (
            SELECT
                id,
                parent_id,
                ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM elements
            WHERE parent_id IS NOT NULL
        )
        UPDATE elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_final"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_v5"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_debug"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_v6"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_simple"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_v4"();""")
    op.execute("""DROP FUNCTION IF EXISTS "rebuild_element_tree_v2"();""")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute("""CREATE FUNCTION "rebuild_element_tree_v2"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        rec RECORD;
    BEGIN
        -- Reset fields
        UPDATE public.elements SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Create a temp table to act as a stack for DFS traversal
        CREATE TEMP TABLE element_stack (
            id integer,
            lvl integer
        ) ON COMMIT DROP;

        -- Push all roots onto the stack
        INSERT INTO element_stack (id, lvl)
        SELECT id, 0 FROM public.elements WHERE parent_id IS NULL ORDER BY id;

        WHILE EXISTS (SELECT 1 FROM element_stack) LOOP
            -- Pop the top element
            SELECT id, lvl INTO rec FROM element_stack ORDER BY lvl DESC, id LIMIT 1;
            DELETE FROM element_stack WHERE id = rec.id;

            -- Set left value
            UPDATE public.elements SET "left" = counter, level = rec.lvl WHERE id = rec.id;
            counter := counter + 1;

            -- Push children onto the stack
            INSERT INTO element_stack (id, lvl)
            SELECT id, rec.lvl + 1 FROM public.elements WHERE parent_id = rec.id ORDER BY id;

            -- Set right value
            UPDATE public.elements SET "right" = counter WHERE id = rec.id;
            counter := counter + 1;
        END LOOP;

        -- Update children_count
        UPDATE public.elements e
        SET children_count = c.cnt
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM public.elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;

        -- Reassign position for siblings
        WITH sibling_groups AS (
            SELECT id, parent_id, ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM public.elements WHERE parent_id IS NOT NULL
        )
        UPDATE public.elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_v4"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        rec RECORD;
        stack RECORD;
        node_id integer;
        lvl integer;
        done boolean := false;
    BEGIN
        -- Reset fields
        UPDATE public.elements SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;
        -- Create a temp table to act as a stack for DFS traversal
        CREATE TEMP TABLE element_stack (
            id integer,
            lvl integer,
            visited boolean DEFAULT false
        ) ON COMMIT DROP;
        -- Push all roots onto the stack
        INSERT INTO element_stack (id, lvl) SELECT id, 0 FROM public.elements WHERE parent_id IS NULL ORDER BY id;
        WHILE EXISTS (SELECT 1 FROM element_stack WHERE visited = false) LOOP
            SELECT id, lvl INTO node_id, lvl FROM element_stack WHERE visited = false ORDER BY lvl DESC, id LIMIT 1;
            -- Set left value
            UPDATE public.elements SET "left" = counter, level = lvl WHERE id = node_id;
            counter := counter + 1;
            -- Mark as visited
            UPDATE element_stack SET visited = true WHERE id = node_id;
            -- Push children onto the stack
            INSERT INTO element_stack (id, lvl) SELECT id, lvl + 1 FROM public.elements WHERE parent_id = node_id ORDER BY id;
            -- Set right value
            UPDATE public.elements SET "right" = counter WHERE id = node_id;
            counter := counter + 1;
        END LOOP;
        -- Update children_count
        UPDATE public.elements e
        SET children_count = c.cnt
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM public.elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;
        -- Reassign position for siblings
        WITH sibling_groups AS (
            SELECT id, parent_id, ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM public.elements WHERE parent_id IS NOT NULL
        )
        UPDATE public.elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_simple"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        root_rec RECORD;
    BEGIN
        -- Reset all tree fields
        UPDATE public.elements
        SET "left" = NULL, "right" = NULL, level = 0;

        -- Simple test: just set left=1, right=2 for first root
        SELECT id INTO root_rec FROM public.elements WHERE parent_id IS NULL ORDER BY id LIMIT 1;

        UPDATE public.elements
        SET "left" = 1, "right" = 2, level = 0
        WHERE id = root_rec.id;

    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_v6"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node RECORD;
    BEGIN
        -- Reset fields
        UPDATE public.elements SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;
        -- Create a temp table to act as a stack for DFS traversal
        CREATE TEMP TABLE element_stack (
            id integer,
            stack_level integer,
            visit_state text
        ) ON COMMIT DROP;
        -- Push all roots onto the stack for entry
        INSERT INTO element_stack (id, stack_level, visit_state)
        SELECT id, 0, 'entry' FROM public.elements WHERE parent_id IS NULL ORDER BY id;
        WHILE EXISTS (SELECT 1 FROM element_stack) LOOP
            SELECT id, stack_level, visit_state FROM element_stack ORDER BY stack_level DESC, id LIMIT 1 INTO node;
            DELETE FROM element_stack WHERE id = node.id AND stack_level = node.stack_level AND visit_state = node.visit_state;
            IF node.visit_state = 'entry' THEN
                -- Set left value
                UPDATE public.elements SET "left" = counter, level = node.stack_level WHERE id = node.id;
                counter := counter + 1;
                -- Push exit state for this node
                INSERT INTO element_stack (id, stack_level, visit_state) VALUES (node.id, node.stack_level, 'exit');
                -- Push children for entry
                INSERT INTO element_stack (id, stack_level, visit_state)
                SELECT id, node.stack_level + 1, 'entry' FROM public.elements WHERE parent_id = node.id ORDER BY id DESC;
            ELSE
                -- Set right value
                UPDATE public.elements SET "right" = counter WHERE id = node.id;
                counter := counter + 1;
            END IF;
        END LOOP;
        -- Update children_count
        UPDATE public.elements e
        SET children_count = c.cnt
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM public.elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;
        -- Reassign position for siblings
        WITH sibling_groups AS (
            SELECT id, parent_id, ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM public.elements WHERE parent_id IS NOT NULL
        )
        UPDATE public.elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_debug"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node RECORD;
        rows_updated integer;
    BEGIN
        -- Reset fields
        UPDATE public.elements SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;
        -- Create a temp table to act as a stack for DFS traversal
        CREATE TEMP TABLE element_stack (
            stack_id serial PRIMARY KEY,
            id integer,
            stack_level integer,
            visit_state text
        ) ON COMMIT DROP;
        -- Push all roots onto the stack for entry
        INSERT INTO element_stack (id, stack_level, visit_state)
        SELECT id, 0, 'entry' FROM public.elements WHERE parent_id IS NULL ORDER BY id;
        WHILE EXISTS (SELECT 1 FROM element_stack) LOOP
            SELECT stack_id, id, stack_level, visit_state FROM element_stack ORDER BY stack_level DESC, stack_id LIMIT 1 INTO node;
            DELETE FROM element_stack WHERE stack_id = node.stack_id;
            IF node.visit_state = 'entry' THEN
                RAISE NOTICE 'ENTRY: id=%, level=%', node.id, node.stack_level;
                UPDATE public.elements SET "left" = counter, level = node.stack_level WHERE id = node.id;
                GET DIAGNOSTICS rows_updated = ROW_COUNT;
                RAISE NOTICE 'Set left for id=%: left=% (rows updated=%)', node.id, counter, rows_updated;
                counter := counter + 1;
                -- Push exit state for this node
                INSERT INTO element_stack (id, stack_level, visit_state) VALUES (node.id, node.stack_level, 'exit');
                -- Push children for entry
                INSERT INTO element_stack (id, stack_level, visit_state)
                SELECT id, node.stack_level + 1, 'entry' FROM public.elements WHERE parent_id = node.id ORDER BY id DESC;
            ELSE
                RAISE NOTICE 'EXIT: id=%, level=%', node.id, node.stack_level;
                UPDATE public.elements SET "right" = counter WHERE id = node.id;
                GET DIAGNOSTICS rows_updated = ROW_COUNT;
                RAISE NOTICE 'Set right for id=%: right=% (rows updated=%)', node.id, counter, rows_updated;
                counter := counter + 1;
            END IF;
        END LOOP;
        -- Update children_count
        UPDATE public.elements e
        SET children_count = c.cnt
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM public.elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;
        -- Reassign position for siblings
        WITH sibling_groups AS (
            SELECT id, parent_id, ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM public.elements WHERE parent_id IS NOT NULL
        )
        UPDATE public.elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_v5"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node RECORD;
    BEGIN
        -- Reset fields
        UPDATE public.elements SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;
        -- Create a temp table to act as a stack for DFS traversal
        CREATE TEMP TABLE element_stack (
            id integer,
            stack_level integer,
            visited boolean DEFAULT false
        ) ON COMMIT DROP;
        -- Push all roots onto the stack
        INSERT INTO element_stack (id, stack_level) SELECT id, 0 FROM public.elements WHERE parent_id IS NULL ORDER BY id;
        WHILE EXISTS (SELECT 1 FROM element_stack WHERE visited = false) LOOP
            SELECT id, stack_level FROM element_stack WHERE visited = false ORDER BY stack_level DESC, id LIMIT 1 INTO node;
            -- Set left value
            UPDATE public.elements SET "left" = counter, level = node.stack_level WHERE id = node.id;
            counter := counter + 1;
            -- Mark as visited
            UPDATE element_stack SET visited = true WHERE id = node.id;
            -- Push children onto the stack
            INSERT INTO element_stack (id, stack_level) SELECT id, node.stack_level + 1 FROM public.elements WHERE parent_id = node.id ORDER BY id;
            -- Set right value
            UPDATE public.elements SET "right" = counter WHERE id = node.id;
            counter := counter + 1;
        END LOOP;
        -- Update children_count
        UPDATE public.elements e
        SET children_count = c.cnt
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM public.elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;
        -- Reassign position for siblings
        WITH sibling_groups AS (
            SELECT id, parent_id, ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM public.elements WHERE parent_id IS NOT NULL
        )
        UPDATE public.elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "rebuild_element_tree_final"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        counter integer := 1;
        node_rec RECORD;
        child_rec RECORD;
        stack_table_created boolean := false;
    BEGIN
        -- Reset all tree fields
        UPDATE public.elements
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Create stack table if it doesn't exist
        BEGIN
            CREATE TEMP TABLE IF NOT EXISTS node_stack (
                stack_order serial,
                node_id integer,
                node_level integer,
                action text -- 'enter' or 'exit'
            ) ON COMMIT DROP;
            stack_table_created := true;
        EXCEPTION WHEN OTHERS THEN
            -- Table might already exist, continue
            DELETE FROM node_stack;
            stack_table_created := true;
        END;

        -- Push all root nodes onto stack (in reverse order for proper LIFO)
        INSERT INTO node_stack (node_id, node_level, action)
        SELECT id, 0, 'enter'
        FROM public.elements
        WHERE parent_id IS NULL
        ORDER BY id DESC;

        -- Process stack until empty
        WHILE EXISTS (SELECT 1 FROM node_stack) LOOP
            -- Pop top item from stack
            SELECT node_id, node_level, action, stack_order
            INTO node_rec
            FROM node_stack
            ORDER BY stack_order DESC
            LIMIT 1;

            DELETE FROM node_stack WHERE stack_order = node_rec.stack_order;

            IF node_rec.action = 'enter' THEN
                -- Set left value and level
                UPDATE public.elements
                SET "left" = counter, level = node_rec.node_level
                WHERE id = node_rec.node_id;
                counter := counter + 1;

                -- Push exit action for this node
                INSERT INTO node_stack (node_id, node_level, action)
                VALUES (node_rec.node_id, node_rec.node_level, 'exit');

                -- Push enter actions for all children (in reverse order)
                INSERT INTO node_stack (node_id, node_level, action)
                SELECT id, node_rec.node_level + 1, 'enter'
                FROM public.elements
                WHERE parent_id = node_rec.node_id
                ORDER BY id DESC;

            ELSE -- action = 'exit'
                -- Set right value
                UPDATE public.elements
                SET "right" = counter
                WHERE id = node_rec.node_id;
                counter := counter + 1;
            END IF;
        END LOOP;

        -- Update children_count
        UPDATE public.elements e
        SET children_count = COALESCE(c.cnt, 0)
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM public.elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;

        -- Update position within siblings
        WITH sibling_groups AS (
            SELECT
                id,
                parent_id,
                ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM public.elements
            WHERE parent_id IS NOT NULL
        )
        UPDATE public.elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;

    END;
    $$;""")
    op.execute("""CREATE OR REPLACE FUNCTION "rebuild_element_tree"() RETURNS void LANGUAGE plpgsql AS $$
    BEGIN
        -- Reset fields
        UPDATE elements
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Recursive CTE for left/right/level assignment
        WITH RECURSIVE tree AS (
            SELECT
                id,
                parent_id,
                1 AS lft,
                2 AS rgt,
                0 AS lvl
            FROM elements
            WHERE parent_id IS NULL
            UNION ALL
            SELECT
                e.id,
                e.parent_id,
                t.rgt,
                t.rgt + 1,
                t.lvl + 1
            FROM elements e
            JOIN tree t ON e.parent_id = t.id
        )
        UPDATE elements e
        SET "left"  = t.lft,
            "right" = t.rgt,
            level   = t.lvl
        FROM tree t
        WHERE e.id = t.id;

        -- Update children_count in bulk
        UPDATE elements e
        SET children_count = c.cnt
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM elements
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;

        -- Reassign position for all siblings, contiguous and deterministic
        WITH sibling_groups AS (
            SELECT
                id,
                parent_id,
                ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM elements
            WHERE parent_id IS NOT NULL
        )
        UPDATE elements e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.drop_index('idx_elements_sibling_order', table_name='elements')
    op.drop_index('idx_elements_parent_id', table_name='elements')
    # ### end Alembic commands ###
