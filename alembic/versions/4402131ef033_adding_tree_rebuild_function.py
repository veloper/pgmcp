"""adding_tree_rebuild_function

Revision ID: 4402131ef033
Revises: 21d253652beb
Create Date: 2025-07-29 18:48:47.653029

"""
from typing import Sequence, Union

import sqlalchemy as sa

from pgvector.sqlalchemy import Vector

from alembic import op


# revision identifiers, used by Alembic.
revision: str = '4402131ef033'
down_revision: Union[str, None] = '21d253652beb'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute("""CREATE OR REPLACE FUNCTION "rebuild_element_tree"() RETURNS void LANGUAGE plpgsql AS $$
    BEGIN
        -- Reset fields
        UPDATE element
        SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Recursive CTE for left/right/level assignment
        WITH RECURSIVE tree AS (
            SELECT
                id,
                parent_id,
                1 AS lft,
                2 AS rgt,
                0 AS lvl
            FROM element
            WHERE parent_id IS NULL
            UNION ALL
            SELECT
                e.id,
                e.parent_id,
                t.rgt,
                t.rgt + 1,
                t.lvl + 1
            FROM element e
            JOIN tree t ON e.parent_id = t.id
        )
        UPDATE element e
        SET "left"  = t.lft,
            "right" = t.rgt,
            level   = t.lvl
        FROM tree t
        WHERE e.id = t.id;

        -- Update children_count in bulk
        UPDATE element e
        SET children_count = c.cnt
        FROM (
            SELECT parent_id, COUNT(*) AS cnt
            FROM element
            WHERE parent_id IS NOT NULL
            GROUP BY parent_id
        ) c
        WHERE e.id = c.parent_id;

        -- Reassign position for all siblings, contiguous and deterministic
        WITH sibling_groups AS (
            SELECT
                id,
                parent_id,
                ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) - 1 AS new_position
            FROM element
            WHERE parent_id IS NOT NULL
        )
        UPDATE element e
        SET position = s.new_position
        FROM sibling_groups s
        WHERE e.id = s.id;
    END;
    $$;""")
    op.execute("""DROP FUNCTION IF EXISTS \"get_env\"""")
    op.execute("""DROP FUNCTION IF EXISTS \"add_numbers\"""")
    op.execute("""DROP FUNCTION IF EXISTS \"pg_settings_reflect_env\"""")
    op.execute("""DROP FUNCTION IF EXISTS \"html_to_sections_jsonb\"""")
    op.execute("""DROP FUNCTION IF EXISTS \"get_embedding\"""")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute("""CREATE FUNCTION "get_embedding"() RETURNS vector LANGUAGE plpython3u AS $$
    import openai
    import os

    model = model_name or os.getenv("OPENAI_EMBEDDING_MODEL_NAME") or "text-embedding-3-small"
    endpoint = endpoint_url or os.getenv("OPENAI_ENDPOINT_URL") or "https://api.openai.com/v1/embeddings"
    api_key = api_key or os.getenv("OPEN AI_API_KEY") or None

    if not api_key:
        raise ValueError("API key must be provided either as a parameter or through the OPENAI_API_KEY environment variable.")

    if not input_text:
        raise ValueError("Input text must be provided.")

    if not model:
        raise ValueError("Model name must be provided either as a parameter or through the OPENAI_EMBEDDING_MODEL_NAME environment variable.")

    if not endpoint:
        raise ValueError("Endpoint URL must be provided either as a parameter or through the OPENAI_ENDPOINT_URL environment variable.")


    client = openai.OpenAI(api_key=api_key, base_url=endpoint)
    try:
        response = client.embeddings.create(model=model, input=input_text)
        return response.data[0].embedding
    except Exception as e:
        raise RuntimeError(f"Failed to get embedding: {e}")
    $$;""")
    op.execute("""CREATE FUNCTION "html_to_sections_jsonb"() RETURNS jsonb LANGUAGE plpython3u AS $$
    import json
    try:
        from langchain.text_splitter import RecursiveCharacterTextSplitter
    except ImportError:
        plpy.error("langchain is not installed in the PL/Python environment.")
    try:
        from bs4 import BeautifulSoup
    except ImportError:
        plpy.error("beautifulsoup4 is not installed in the PL/Python environment.")
    soup = BeautifulSoup(html, "html.parser")
    text = soup.get_text(separator="\n")
    splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=50)
    sections = splitter.split_text(text)
    result = [{"section": i+1, "text": s} for i, s in enumerate(sections)]
    return json.dumps(result)
    $$;""")
    op.execute("""CREATE FUNCTION "pg_settings_reflect_env"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
      r RECORD;
    BEGIN
      CREATE EXTENSION IF NOT EXISTS envvar;

      FOR r IN
        WITH base_settings AS (
          SELECT
            name AS pg_key,
            setting AS pg_value,
            boot_val AS pg_default_value,
            vartype AS cast_type,
            CONCAT('PG_', UPPER(REPLACE(name, '.', '__'))) AS env_key
          FROM pg_settings
          WHERE
            context IN ('user', 'superuser', 'sighup', 'backend')
            AND vartype NOT IN ('internal')
            AND name NOT LIKE 'local%'
            AND name NOT LIKE 'session%'
        ),
        env_value_settings AS (
          SELECT
            *,
            get_env(env_key) AS env_value
          FROM base_settings
        ),
        env_value_act AS (
          SELECT *,
            (
              CASE
                WHEN env_value IS NULL THEN '__NO_OP__'
                WHEN env_value::text = ''::text THEN '__UNSET__'
                ELSE (
                  CASE
                    WHEN pg_value::text != env_value::text THEN '__UPDATE__'
                    ELSE '__NO_OP__'
                  END
                )
              END
            ) AS act
          FROM env_value_settings
        ),
        env_value_cast AS (
          SELECT *,
            (
              CASE
              WHEN act = '__NO_OP__' THEN NULL
              WHEN act = '__UNSET__' THEN pg_default_value
              ELSE env_value
              END
            ) AS update_value
          FROM env_value_act
        )
        SELECT * FROM env_value_cast
        WHERE update_value IS NOT NULL
      LOOP
        RAISE NOTICE 'Syncing setting: % -> %', r.pg_key, r.update_value;
        EXECUTE format('ALTER SYSTEM SET %I = %L', r.pg_key, r.update_value);
      END LOOP;

      PERFORM pg_reload_conf();
    END;
    $$;""")
    op.execute("""CREATE FUNCTION "add_numbers"() RETURNS int4 LANGUAGE plpgsql AS $$ BEGIN RETURN a + b; END; $$;""")
    op.execute("""CREATE FUNCTION "get_env"() RETURNS text LANGUAGE plpython3u AS $$
    import os
    return os.environ.get(key)
    $$;""")
    op.execute("""CREATE OR REPLACE FUNCTION "rebuild_element_tree"() RETURNS void LANGUAGE plpgsql AS $$
    DECLARE
        root RECORD;
    BEGIN
        -- Reset fields
        UPDATE element SET "left" = NULL, "right" = NULL, level = 0, children_count = 0;

        -- Recursive function to traverse and set left/right/level
        CREATE TEMP TABLE tmp_tree(id INT, lft INT, rgt INT, lvl INT) ON COMMIT DROP;

        -- Helper function for traversal
        CREATE OR REPLACE FUNCTION traverse(node_id INT, lvl INT, lft INT) RETURNS INT AS $inner$
        DECLARE
            my_left INT := lft;
            my_right INT;
            child RECORD;
        BEGIN
            lft := lft + 1;
            FOR child IN SELECT id FROM element WHERE parent_id = node_id ORDER BY id LOOP
                lft := traverse(child.id, lvl + 1, lft);
            END LOOP;
            my_right := lft;
            INSERT INTO tmp_tree VALUES (node_id, my_left, my_right, lvl);
            RETURN lft + 1;
        END;
        $inner$ LANGUAGE plpgsql;

        -- Traverse all roots
        FOR root IN SELECT id FROM element WHERE parent_id IS NULL ORDER BY id LOOP
            PERFORM traverse(root.id, 0, 1);
        END LOOP;

        -- Update left/right/level from tmp_tree
        UPDATE element e
        SET "left" = t.lft, "right" = t.rgt, level = t.lvl
        FROM tmp_tree t
        WHERE e.id = t.id;

        -- Update children_count
        UPDATE element e
        SET children_count = (
            SELECT COUNT(*) FROM element c WHERE c.parent_id = e.id
        );

        -- Update position for siblings with NULL position
        WITH siblings AS (
            SELECT
                id,
                parent_id,
                position,
                ROW_NUMBER() OVER (PARTITION BY parent_id ORDER BY id) AS rn
            FROM element
        )
        UPDATE element e
        SET position = s.rn - 1
        FROM siblings s
        WHERE e.id = s.id AND e.position IS NULL;

        -- Cleanup
        DROP FUNCTION traverse(INT, INT, INT);
        DROP TABLE tmp_tree;
    END;
    $$;""")
    # ### end Alembic commands ###
